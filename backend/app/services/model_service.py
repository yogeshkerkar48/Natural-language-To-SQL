"""
Model Service using g4f library for NL2SQL generation.
Uses Qwen/Qwen2.5-Coder-7B-Instruct for SQL generation.
"""

from g4f.client import Client
import re
from app.services.prompt_builder import build_prompt

class ModelService:
    def __init__(self):
        print("Initializing g4f Model Service...")
        self.client = Client()
        # Primary model: Qwen for code generation
        self.model = "gpt-4"  # g4f uses this as a generic identifier
        print("g4f Model Service initialized")

    def fix_sql_syntax(self, sql: str) -> str:
        """
        Fix common SQL syntax errors generated by the model.
        
        Args:
            sql: SQL query that may have syntax errors
            
        Returns:
            Corrected SQL query
        """
        # Fix: SELECT FROM table -> SELECT * FROM table
        sql = re.sub(r'\bSELECT\s+FROM\b', 'SELECT * FROM', sql, flags=re.IGNORECASE)
        
        # Fix: COUNT() -> COUNT(*)
        sql = re.sub(r'\bCOUNT\s*\(\s*\)', 'COUNT(*)', sql, flags=re.IGNORECASE)
        
        # Fix: SUM() -> SUM(*) (though this is still wrong, at least it won't crash)
        sql = re.sub(r'\bSUM\s*\(\s*\)', 'SUM(*)', sql, flags=re.IGNORECASE)
        
        # Fix: AVG() -> AVG(*)
        sql = re.sub(r'\bAVG\s*\(\s*\)', 'AVG(*)', sql, flags=re.IGNORECASE)
        
        return sql

    def clean_sql_output(self, raw_output: str) -> str:
        """
        Clean the model output to extract pure SQL.
        
        Removes:
        - SQL code fences (```sql)
        - Markdown formatting
        - Extra whitespace
        - Explanatory text
        
        Args:
            raw_output: Raw output from model
            
        Returns:
            Clean SQL query
        """
        # Remove code fences
        output = re.sub(r'```sql\s*', '', raw_output)
        output = re.sub(r'```\s*', '', output)
        
        # Remove markdown bold/italic (safer version)
        output = output.replace('**', '').replace('__', '')
        
        # Extract SQL if there's explanatory text
        # Look for any valid SQL statement start
        
        # 1. Check for Common Table Expressions (WITH ...) - strict check to avoid matching "with provided schema"
        cte_match = re.search(r'(WITH\s+[a-zA-Z0-9_]+\s+AS\s*\(.+?;?)\s*$', output, re.IGNORECASE | re.DOTALL)
        
        # 2. Check for standard SQL starting keywords
        standard_match = re.search(r'((?:SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER|TRUNCATE|GRANT|REVOKE|COMMIT|ROLLBACK|SAVEPOINT|SET|SHOW|DESCRIBE|EXPLAIN)\s+.+?;?)\s*$', output, re.IGNORECASE | re.DOTALL)
        
        if cte_match:
            output = cte_match.group(1)
        elif standard_match:
            output = standard_match.group(1)
        
        # Clean whitespace
        output = output.strip()
        
        # Fix common syntax errors
        output = self.fix_sql_syntax(output)
        
        # Ensure it ends with semicolon
        if output and not output.endswith(';'):
            output += ';'
            
        return output

    def generate_sql(self, schema_str: str, question: str, database_type: str = "MySQL") -> str:
        """
        Generate SQL from natural language question and schema.
        Includes automatic retry logic for unreliable free AI models.
        
        Args:
            schema_str: Database schema
            question: User's natural language question
            database_type: Type of database (MySQL, PostgreSQL, etc.)
            
        Returns:
            Generated SQL query
            
        Raises:
            Exception: If model call fails after all retries
        """
        max_retries = 5
        last_error = None
        
        for attempt in range(1, max_retries + 1):
            try:
                # Build the prompt
                prompt = build_prompt(schema_str, question, database_type=database_type)
                
                print(f"\n--- PROMPT SENT TO AI (Attempt {attempt}) ---")
                print(prompt)
                print(f"{'-'*40}\n")
                
                # Call g4f model
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=[
                        {"role": "user", "content": prompt}
                    ],
                    timeout=30  # 30 second timeout
                )
                
                # Extract response
                raw_sql = response.choices[0].message.content
                
                # Clean the output
                clean_sql = self.clean_sql_output(raw_sql)
                
                # Check for error responses
                if "ERROR:" in clean_sql.upper():
                    last_error = clean_sql
                    if attempt < max_retries:
                        print(f"Attempt {attempt} failed with error response, retrying...")
                        continue
                    raise ValueError(clean_sql)
                
                # Success!
                if attempt > 1:
                    print(f"âœ“ Succeeded on attempt {attempt}")
                return clean_sql
                
            except Exception as e:
                last_error = str(e)
                if attempt < max_retries:
                    print(f"Attempt {attempt}/{max_retries} failed: {str(e)}, retrying...")
                    continue
                else:
                    print(f"All {max_retries} attempts failed")
                    raise Exception(f"Failed to generate SQL after {max_retries} attempts: {last_error}")
        
        # This shouldn't be reached, but just in case
        raise Exception(f"Failed to generate SQL: {last_error}")

# Global instance
model_service = ModelService()
